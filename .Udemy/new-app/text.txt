I. НАСТРОЙКА НА СРЕДАТА
    - npm i -g @angular/cli <- освен ако не е инсталирано
    - ng new new-app
    - cd new-app
    - npm i --save bootstrap@3 <- bootstrap v.3
      : в angular.json-architect-build-styles: добавяме "node_modules/bootstrap/dist/css/bootstrap.min.css"
    - ng s
    - трием и тестваме app.component.html с bootstrap

II. АНАЛИЗИРАМЕ АРХИТЕКТУРАТА
    - какви компоненти ще са ни необходими, каква е връзката помежду им

III. СЪЗДАВАНЕ НА КОМПОНЕНТИТЕ
  1. HEADER
    - папка header в app/ с файлове .ts (@Component със selector и templateUrl) и .html
    - в app.module.ts:
      : добавяме HeaderComponent в declarations
      : импортваме го в началото с import { HeaderComponent } from "./...";
  2. RECIPES
    = компонент, който ще държи елемента, в него ще има details
    - ng g c recipes --skipTests true <- за да не създава тестови файл
  3. RECIPE-LIST
    = в папката recipes
    - ng g c recipes/recipe-list --skipTests true
  4. RECIPE-DETAIL
    - ng g c recipes/recipe-detail --skipTests true
  5. RECIPE-ITEM
    = в папката recipe-list
    - ng g c recipes/recipe-list/recipe-item --skipTests true
  6. SHOPPING-LIST
    - ng g c shopping-list --skipTests true
  7. SHOPPING-EDIT
    - ng g c shopping-list/shopping-edit --skipTests true

IV. ПОДРЕЖДАМЕ КОМПОНЕНТИТЕ
  1. В app.component.html слагаме селектора <app-recipes>, под него <app-shopping-list>
  2. В recipes.component.html правим .row, .col-md-5, .col-md-7 <- две колони, съотв. за recipe-list и recipe-detail
  3. В recipe-list.component.html слагаме recipe-item (само селектора)
  4. В shopping-list.component.html слагаме .row, .col-xs-10 (широка колона) и в нея shopping-edit селектора

V. ДОБАВЯМЕ СЪДЪРЖАНИЕ НА КОМПОНЕНТИТЕ
  1. В header.component.html добавяме меню и drop-down меню
  2. Създаваме модел Recipe
    = моделът е typescript файл, клас
    = определя как ще изглежда отделната рецепта
  3. Recipe-list
    - в recipe-list.component създаваме масив recipes = [];
    - в папка recipes създаваме файл recipe.model.ts
    - задаваме тип на масива resipes: recipes: Recipe[] = [], като импортваме модела
    - създаваме една рецепта в масива: new Recipe()
    - в recipe-list.component.html: *ngFor, {{ recipe.name }}, ...
  4. Recipe-detail
    - recipe-detail.component.html - правим го
  5. Shopping-list
    - правим html-а
    - в ts-файла - добавяме ingredients = [];
  6. Ingredients модел
    - създаваме папка app/shared и в нея ingredient.model.ts (съкратен вариант)
    - в shopping-list.component.ts го импортваме и ползваме като тип на масива ingredients
      : добавяме и нов Ingredient('')
  7. Shopping-edit
    - html

VI. DEBUGGING
  1. EXCEPTION: inline template:4:6 <- line, column, но не в нашите файлове
  2. AUGURY - chrome extension

V. DATA BINDING
! Всички пропъртита се виждат само в рамките на компонентата
! Ако искаме да ги достъпваме отвън, трябва да добавим декоратор към пропъртито 
  -> слагаме @Input() преди декларацията на пропъртито, трябва да го импортнем от @angular/core
  = така може да се достъпва от всеки html компонент, в който има селектор към това пропърти
! Ако искаме да достъпим метод отвън (от app.component.ts напр.) - правим нов метод, който да слуша, напр. (serverCreated)="onServerAdded($event)", който слагаме при селектора
  -> този метод, който слуша, се декларира в компонентата, от която идва, напр. @Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();, което се импортва от @angular/core
! EventEmitter<{}>() е обект в angular framework, който ни позволява да емитваме собствени събития (to emit your own events)
  -> в компонентата, от която идва, имаме функция onAddServer() {this.serverCreated.emit({serverName: this.newServerName, serverContent: this.newServerContent});} <- емитва събитието

  1. VIEW ENCAPSULATION
  -> в декоратора на ts-файла добавяме encapsulation: ViewEncapsulation.none (Emulated е дефолт, т.е има, ShadowDom e същото, но само в браузърите, които имат) -> даденият елемент не ползва вече енкапсулация и ако се добави стил в него - прилага се глобално!

  2. LOCAL REFERENCE
! може да се слага върху всеки елемент: #serverNameInput 
  - това е референция към целия html елемент; ползва се вместо two-way binding
  - може да се използват навсякъде в приложението, но само в html-ите

  3. ViewChild
  ! @ViewChild('serverContentInput', {static: true}) serverContentInput: ElementRef;
    -> добавя се втори аргумент на ф-цията {static: true} САМО ако смятаме да достъпваме елемента в ngOnInit()
    = начин да получим достъп до всеки елемент директно от ts кода преди да извикаме метода:
      : @ViewChild('serverContentInput') serverContentInput: ElementRef <- в ts файла
      : стойността на serverContentInput се достъпва: this.serverContentInput.nativeElement.value;
    - @ContentChild('')

! Т.е. locar references могат да се подават на методи или могад да се fetch-ват от @ViewChild
! Не бива да се променят DOM елементите по този начин, въпреки че може!

  4. NG директива <ng-content> - чрез този селектор се маркира мястото в компонентата, където ще се слага текст; а html кода за текста се поставя в app.component.html - между отварящата и затварящата скоба на селектора на компонентата

VI. LIFE CYCLE HOOKS
  1. ngOnChanges - called after a bound input property changes
  2. ngOnInit - called once the comp is initialized, after the constructor
  3. ngDoCheck - executed a lot of times: during every change detection run - checks if something changed
  4. ngAfterContentInit - called after content has been projected into view
  5. ngAfterContentChecked - after content has been checked
  6. ngAfterViewInit - after view has been initialized
  7. ngAfterViewChecked - after view has been checked
  8. ngOnDestroy - once the comp is about to be destroyed

